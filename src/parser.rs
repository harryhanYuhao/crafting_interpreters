//! The purpose of the parser is to parse the token vector and return abstract syntax tree.
//! The token vectors is generated by the scanner

use crate::token::{self, Token, TokenArcVec, TokenType};
use crate::AST_Node::*;
use std::convert::From;
use std::error::Error;
use std::fmt;
use std::iter::{Enumerate, FromIterator};
use std::ops::{Index, IndexMut, Sub};
use std::sync::{Arc, Mutex};

// This struct behaves like a vec
pub struct ParseTreeUnfinshed {
    content: Vec<Arc<Mutex<AST_Node>>>,
}

impl ParseTreeUnfinshed {
    pub fn new() -> Self {
        ParseTreeUnfinshed {
            content: Vec::new(),
        }
    }

    pub fn push(&mut self, item: Arc<Mutex<AST_Node>>) {
        self.content.push(item);
    }

    pub fn extend(&mut self, ext: ParseTreeUnfinshed) {
        self.content.extend(ext.content)
    }

    pub fn remove(&mut self, index: usize) {
        self.content.remove(index);
    }

    pub fn len(&self) -> usize {
        self.content.len()
    }

    pub fn slice(&mut self, start: usize, end: usize) -> Self {
        let content = self.content[start..end].to_vec();
        ParseTreeUnfinshed { content }
    }

    pub fn replace(&mut self, index: usize, node: Arc<Mutex<AST_Node>>) {
        self.content[index] = node;
    }

    pub fn get_finished_node(&self) -> Option<Arc<Mutex<AST_Node>>> {
        if self.content.len() > 1 {
            panic!("Tree is in unfinished state!");
        }
        if self.content.len() == 1 {
            return Some(self.content[0].clone());
        }
        None
    }
}

impl FromIterator<Arc<Mutex<AST_Node>>> for ParseTreeUnfinshed {
    fn from_iter<I: IntoIterator<Item = Arc<Mutex<AST_Node>>>>(iter: I) -> Self {
        let mut res = ParseTreeUnfinshed::new();
        for i in iter {
            res.push(i)
        }
        res
    }
}

impl From<&TokenArcVec> for ParseTreeUnfinshed {
    fn from(s: &TokenArcVec) -> ParseTreeUnfinshed {
        s.iter()
            .map(|token| Arc::new(Mutex::new(AST_Node::from(Arc::clone(token)))))
            .collect()
    }
}

impl Index<usize> for ParseTreeUnfinshed {
    type Output = Arc<Mutex<AST_Node>>;

    fn index(&self, index: usize) -> &Arc<Mutex<AST_Node>> {
        &self.content[index]
    }
}

impl IndexMut<usize> for ParseTreeUnfinshed {
    fn index_mut(&mut self, index: usize) -> &mut Arc<Mutex<AST_Node>> {
        &mut self.content[index]
    }
}

#[derive(Debug)]
pub enum ParseState {
    Finished,
    Unfinished,
    Err(Box<dyn Error>),
}

impl fmt::Debug for ParseTreeUnfinshed {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        let mut res = String::new();
        for i in &self.content {
            let item = i.clone();
            let item = item.lock().unwrap();
            res.push_str(&format!("{}", item));
            res.push_str("\n");
        }
        // remove the extra newline
        if self.content.len() > 0 {
            res.remove(res.len() - 1);
        }
        write!(f, "{}", res)
    }
}

/// Public API for parsing the tree
pub fn parse(tokens: &TokenArcVec, tree: &mut ParseTreeUnfinshed) -> ParseState {
    let input_list = ParseTreeUnfinshed::from(tokens);
    tree.extend(input_list);

    return real_parse(tree);
}

/// This is for subparse: not available for public api
/// The grand parse is reduced to several subparses, the order of which follows the  order of
/// precdence.
/// A finished subparse means there are no more avaiable tree to be made in that subparse, but the
/// whole parse may not be finished
/// A unfinished subparse means:
///     it needs more token from the next line to finish the subparse, in this case the parse is unfinished
/// Err means unrecoverable error. Terminated immediately
enum SubParseState {
    Unfinished,
    Finished,
    Err(Box<dyn Error>),
}

macro_rules! error_handle_SubParseState {
    ($fun:expr) => {
        match $fun {
            SubParseState::Unfinished => return ParseState::Unfinished,
            SubParseState::Err(err) => return ParseState::Err(err),
            _ => {}
        }
    };
}

// this is the real parse. Define here for recursion
fn real_parse(tree: &mut ParseTreeUnfinshed) -> ParseState {
    if tree.len() <= 1 {
        return ParseState::Finished;
    }

    error_handle_SubParseState!(parse_parenthesis(tree));
    // parse times and devide
    error_handle_SubParseState!(parse_ternary_left_assoc(
        tree,
        &vec![AST_Type::Expr, AST_Type::PotentialStmt],
        &vec![TokenType::STAR, TokenType::SLASH],
        &vec![AST_Type::Expr, AST_Type::PotentialStmt],
    ));
    // parse plus minus
    error_handle_SubParseState!(parse_ternary_left_assoc(
        tree,
        &vec![AST_Type::Expr, AST_Type::PotentialStmt],
        &vec![TokenType::PLUS, TokenType::MINUS],
        &vec![AST_Type::Expr, AST_Type::PotentialStmt],
    ));

    if tree.len() == 1 {
        return ParseState::Finished;
    }
    return ParseState::Unfinished;
}

// recursively parse parenthesis
fn parse_parenthesis(tree: &mut ParseTreeUnfinshed) -> SubParseState {
    // let outer_paren_loc: Vec<(usize, usize)> = Vec::new();
    let mut start_idx: (bool, usize) = (false, 0); // bool is false means uninitiated,
    let mut end_idx: (bool, usize) = (false, 0);
    let mut paren_count: i64 = 0;
    let length = tree.len();
    let mut i = 0;
    while i < length {
        match AST_Node::get_token_type_from_arc(tree[i].clone()) {
            TokenType::LEFT_PAREN => {
                if !start_idx.0 {
                    start_idx = (true, i);
                }
                paren_count += 1;
            }
            TokenType::RIGHT_PAREN => {
                paren_count -= 1;
                // error checking
                if paren_count < 0 {
                    //TODO: ERROR HANDLING
                    return SubParseState::Err("Extra Paren!".into());
                } else if paren_count == 0 {
                    end_idx = (true, i);
                    break;
                }
            }
            _ => {}
        }
        i += 1;
    }
    // error handling
    if start_idx.0 && !end_idx.0 {
        // in such case paren_count never reached 0
        return SubParseState::Err("More left paren than right paren!".into());
    } else if start_idx.0 && end_idx.0 {
        // the work begin
        // recursive call;
        let mut slice = tree.slice(start_idx.1 + 1, end_idx.1);
        let sup_parse = real_parse(&mut slice);
        match sup_parse {
            ParseState::Err(e) => return SubParseState::Err(e),
            ParseState::Unfinished => {
                return SubParseState::Err("Parenthesis content unterminated".into())
            }
            ParseState::Finished => {
                let res = slice.get_finished_node();
                // the parse result may be none
                match res {
                    None => {
                        tree.remove(end_idx.1);
                        tree.remove(start_idx.1);
                    }
                    Some(result) => {
                        for _ in (start_idx.1 + 1)..=(end_idx.1) {
                            tree.remove(start_idx.1 + 1);
                        }
                        tree.replace(start_idx.1, result);

                        // start parsing from the new node
                        real_parse(tree);
                    }
                }
            }
        }
    }
    SubParseState::Finished
}

/// This function constructs the ternary left associtive operators into tree, whose grammer is
/// similar to +, -, *, /
fn parse_ternary_left_assoc(
    tree: &mut ParseTreeUnfinshed,
    left_AST_types: &[AST_Type],
    operator_token_types: &[TokenType],
    right_AST_types: &[AST_Type],
) -> SubParseState {
    let mut length = tree.len();
    let mut i = 0;

    // ignore the last two tokens
    while i + 2 < length {
        // match the type of the first token
        // match get_AST_Type_from_arc(Arc::clone(&tree[i])) {
        if !AST_Node::arc_belongs_to_AST_type(tree[i].clone(), left_AST_types) {
            i += 1;
            continue;
        }
        // check the second token
        if !AST_Node::arc_belongs_to_Token_type(tree[i + 1].clone(), operator_token_types) {
            i += 1;
            continue;
        }

        // check the third toklen
        if !AST_Node::arc_belongs_to_AST_type(tree[i + 2].clone(), right_AST_types) {
            return SubParseState::Unfinished;
        }
        // Construct the tree
        {
            let mut root = tree[i + 1].lock().unwrap();
            root.set_AST_Type(AST_Type::Expr);
            root.append_child(tree[i].clone());
            root.append_child(tree[i + 2].clone());
        }
        // remove the first expr, note the
        // length of the array decreases by
        // one
        tree.remove(i);
        // remove the second expr
        tree.remove(i + 1);
        length -= 2;
        // skipping i += 1; the new node
        // needs to be parsed again
    }
    SubParseState::Finished
}
