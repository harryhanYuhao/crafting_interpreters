//! The purpose of the parser is to parse the token vector and return abstract syntax tree.
//! The token vectors is generated by the scanner

use crate::token::TokenArcVec;
use crate::AST_Node::{get_AST_Type_from_arc, AST_Node};
use std::convert::From;
use std::error::Error;
use std::fmt;
use std::iter::FromIterator;
use std::sync::{Arc, Mutex};
use std::ops::{Index, IndexMut};

pub struct ParseTreeUnfinshed {
    content: Vec<Arc<Mutex<AST_Node>>>,
}

impl ParseTreeUnfinshed {
    pub fn new() -> Self {
        ParseTreeUnfinshed {
            content: Vec::new(),
        }
    }

    pub fn push(&mut self, item: Arc<Mutex<AST_Node>>) {
        self.content.push(item);
    }

    pub fn extend(&mut self, ext: ParseTreeUnfinshed) {
        self.content.extend(ext.content)
    }

    pub fn len(&self) -> usize {
        self.content.len()
    }
}

impl FromIterator<Arc<Mutex<AST_Node>>> for ParseTreeUnfinshed {
    fn from_iter<I: IntoIterator<Item = Arc<Mutex<AST_Node>>>>(iter: I) -> Self {
        let mut res = ParseTreeUnfinshed::new();
        for i in iter {
            res.push(i)
        }
        res
    }
}

impl From<&TokenArcVec> for ParseTreeUnfinshed {
    fn from(s: &TokenArcVec) -> ParseTreeUnfinshed {
        s.iter()
            .map(|token| Arc::new(Mutex::new(AST_Node::from(Arc::clone(token)))))
            .collect()
    }
}


impl Index<usize> for ParseTreeUnfinshed {
    type Output = Arc<Mutex<AST_Node>>;

    fn index(&self, index: usize) -> &Arc<Mutex<AST_Node>> {
        &self.content[index]
    }
}

impl IndexMut<usize> for ParseTreeUnfinshed {
    fn index_mut(&mut self, index: usize) -> &mut Arc<Mutex<AST_Node>> {
        &mut self.content[index]
    }
}

pub enum ParseState {
    Finished(Arc<Mutex<AST_Node>>),
    Unfinished,
    Err(Box<dyn Error>),
}

impl fmt::Debug for ParseTreeUnfinshed {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        let mut res = String::new();
        for i in &self.content {
            let item = i.clone();
            let item = item.lock().unwrap();
            res.push_str(&format!("{}", item));
            res.push_str("\n");
        }
        // remove the extra newline
        res.remove(res.len() - 1);
        write!(f, "{}", res)
    }
}

/// Public API for parsing the tree 
///
pub fn parse(tokens: &TokenArcVec, tree: &mut ParseTreeUnfinshed) -> ParseState {
    let mut input_list = ParseTreeUnfinshed::from(tokens);
    input_list.push(AST_Node::random_expr(1).into());
    tree.extend(input_list);
    println!("{:?}", tree);

    ParseState::Unfinished
}

/// This is for subparse: not available for public api
/// The grand parse is reduced to several subparses, the order of which follows the  order of
/// precdence. 
/// A finished subparse means there are no more avaiable tree to be made in that subparse, but the
/// whole parse may not be finished 
/// A unfinished subparse means:
///     it needs more token from the next line to finish the subparse, in this case the parse is unfinished
/// Err means unrecoverable error. Terminated immediately
enum SubParseState{
    Unfinished,
    Finished,
    Err(Box<dyn Error>)
}

// this is the real parse. Define here for recursion
fn real_parse(tree: &mut ParseTreeUnfinshed) -> ParseState {

    match parse_plus_minux(tree) {
        SubParseState::Unfinished => {return ParseState::Unfinished},
        SubParseState::Err(err) => {return ParseState::Err(err)}
        _ => {},
    }
    ParseState::Unfinished
}

fn parse_plus_minux(tree: &mut ParseTreeUnfinshed) -> SubParseState {
    for i in 0..tree.len() {
        match get_AST_Type_from_arc(Arc::clone(&tree[i])) {
            _ => {}
        }
    }
    SubParseState::Unfinished
}
